\name{add.init}
\alias{add.init}
\title{add arbitrary initialization functions to a strategy}
\usage{
  add.init(strategy, name, arguments, parameters = NULL,
  label = NULL, ..., enabled = TRUE, indexnum = NULL, store
  = FALSE)
}
\arguments{
  \item{strategy}{an object (or the name of an object) of
  type 'strategy' to add the init function definition to}

  \item{name}{name of the init, must correspond to an R
  function}

  \item{arguments}{named list of default arguments to be
  passed to an init function when executed}

  \item{parameters}{vector of strings naming parameters to
  be saved for apply-time definition,default NULL, only
  needed if you need special names to avoid argument
  collision}

  \item{label}{arbitrary text label for init output,
  default NULL}

  \item{...}{any other passthru parameters}

  \item{enabled}{TRUE/FALSE whether the init is enabled for
  use in applying the strategy, default TRUE}

  \item{indexnum}{if you are updating a specific init, the
  index number in the $init list to update}

  \item{store}{TRUE/FALSE whether to store the strategy in
  the .strategy environment, or return it.  default FALSE}
}
\value{
  if \code{strategy} was the name of a strategy, the name.
  It it was a strategy, the updated strategy.
}
\description{
  \code{\link{initStrategy}} will run a series of common
  initialization functions at the beginning of an
  \code{\link{applyStrategy}} call.  This function allows
  the user to add arbitrary initialization functions to the
  sequence.
}
\details{
  These arbitrary functions will be added to the
  \code{init} slot of the strategy object and when
  \code{applyStrategy} is evaluated, the arbitrary
  initialization functions will be evaluated after the
  standardized functions.

  For example, if your strategy uses a synthetic basket
  instrument, you could use this initialization slot to add
  a custom constructor to build the basket instrument time
  series and modify the symbols slot(s) of the strategy and
  portfolio.
}

