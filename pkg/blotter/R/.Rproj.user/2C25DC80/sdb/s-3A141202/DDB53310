{
    "contents" : "#' Add transactions to a portfolio.\n#' \n#' When a trade or adjustment is made to the Portfolio, the addTxn function \n#' calculates the value and average cost of the transaction,  the change in \n#' position, the resulting positions average cost, and any realized profit \n#' or loss (net of fees) from the transaction. Then it stores the transaction \n#' and calculations in the Portfolio object.\n#'\n#' Fees are indicated as negative values and will be\n#' subtracted from the transaction value. TxnFees can either\n#' be a fixed numeric amount, or a function (or charavcter\n#' name of a function) in which case the function is\n#' evaluated to determine the fee amount.\n#'\n#' The \\code{\\link{pennyPerShare}} function provides a simple\n#' example of a transaction cost function.\n#'\n#' Transactions which would cross the position through zero\n#' will be split into two transactions, one to flatten the\n#' position, and another to initiate a new position on the\n#' opposite side of the market.  The new (split) transaction\n#' will have its timestamp incremented by \\code{eps} to\n#' preserve ordering.\n#'\n#' This transaction splitting vastly simplifies realized P&L\n#' calculations elsewhere in the code. Such splitting also\n#' mirrors many execution platforms and brokerage\n#' requirements in particular asset classes where the side\n#' of a trade needs to be specified with the order.\n#'\n#' The \\code{addTxns} function allows you to add multiple\n#' transactions to the portfolio, which is much faster than\n#' adding them one at a time. The \\code{TxnData} object must\n#' have \"TxnQty\" and \"TxnPrice\" columns, while the \"TxnFees\"\n#' column is optional.\n#' \n#' If \\code{TxnFees} is the name of a function, the function \n#' will be called with \\code{TxnFees(TxnQty, TxnPrice, Symbol)}\n#' so a user supplied fee function must at the very least take \n#' dots to avoid an error. We have chosen not to use named arguments \n#' to reduce issues from user-supplied fee functions. \n#' \n#' @param Portfolio  A portfolio name that points to a portfolio object structured with \\code{initPortf()}\n#' @param Symbol An instrument identifier for a symbol included in the portfolio, e.g., \"IBM\"\n#' @param TxnDate  Transaction date as ISO 8601, e.g., '2008-09-01' or '2010-01-05 09:54:23.12345'\n#' @param TxnQty Total units (such as shares or contracts) transacted.  Positive values indicate a 'buy'; negative values indicate a 'sell'\n#' @param TxnPrice  Price at which the transaction was done\n#' @param \\dots Any other passthrough parameters\n#' @param TxnFees Fees associated with the transaction, e.g. commissions., See Details\n#' @param allowRebates whether to allow positive (rebate) TxnFees, default FALSE\n#' @param ConMult Contract/instrument multiplier for the Symbol if it is not defined in an instrument specification\n#' @param verbose If TRUE (default) the function prints the elements of the transaction in a line to the screen, e.g., \"2007-01-08 IBM 50 @@ 77.6\". Suppress using FALSE.\n#' @param eps value to add to force unique indices\n#' @param TxnData  An xts object containing all required txn fields (for addTxns)\n#' @note \n#' The addTxn function will eventually also handle other transaction types, \n#' such as adjustments for corporate actions or expire/assign for options. \n#' See \\code{\\link{addDiv}} \n#'\n#' @seealso \\code{\\link{addTxns}}, \\code{\\link{pennyPerShare}}, \\code{\\link{initPortf}}\n#' @author Peter Carl, Brian G. Peterson\n#' @export addTxn\n#' @export addTxns\naddTxn <- function(Portfolio, Symbol, TxnDate, TxnQty, TxnPrice, ..., TxnFees=0, allowRebates=FALSE, ConMult=NULL, verbose=TRUE, eps=1e-06)\n{ \n    pname <- Portfolio\n    #If there is no table for the symbol then create a new one\n    if(is.null(.getPortfolio(pname)$symbols[[Symbol]]))\n        addPortfInstr(Portfolio=pname, symbols=Symbol)\n    Portfolio <- .getPortfolio(pname)\n\n    PrevPosQty = getPosQty(pname, Symbol, TxnDate)\n    \n    if(!is.timeBased(TxnDate) ){\n        TxnDate<-as.POSIXct(TxnDate)\n    }\n\n    # Coerce the transaction fees to a function if a string was supplied\n    if(is.character(TxnFees)) {\n        TF <- try(match.fun(TxnFees), silent=TRUE)\n        if (!inherits(TF,\"try-error\")) TxnFees<-TF\n    }\n    # Compute transaction fees if a function was supplied\n    if (is.function(TxnFees)) {\n      txnfees <- TxnFees(TxnQty, TxnPrice, Symbol) \n    } else {\n      txnfees<- as.numeric(TxnFees)\n    }\n    \n    if(is.null(txnfees) || is.na(txnfees))\n        txnfees <- 0\n    if(txnfees>0 && !isTRUE(allowRebates))\n        stop('Positive Transaction Fees should only be used in the case of broker/exchange rebates for TxnFees ',TxnFees,'. See Documentation.')\n    \n    # split transactions that would cross through zero\n    if(PrevPosQty!=0 && sign(PrevPosQty+TxnQty)!=sign(PrevPosQty) && PrevPosQty!=-TxnQty){\n        txnFeeQty=txnfees/abs(TxnQty) # calculate fees pro-rata by quantity\n        addTxn(Portfolio=pname, Symbol=Symbol, TxnDate=TxnDate, TxnQty=-PrevPosQty, TxnPrice=TxnPrice, ..., \n                TxnFees = txnFeeQty*abs(PrevPosQty), ConMult = ConMult, verbose = verbose, eps=eps)\n        TxnDate=TxnDate+2*eps #transactions need unique timestamps, so increment a bit\n        TxnQty=TxnQty+PrevPosQty\n        PrevPosQty=0\n        txnfees=txnFeeQty*abs(TxnQty+PrevPosQty)\n    }\n    \n    if(is.null(ConMult) | !hasArg(ConMult)){\n        tmp_instr<-try(getInstrument(Symbol), silent=TRUE)\n        if(inherits(tmp_instr,\"try-error\") | !is.instrument(tmp_instr)){\n            warning(paste(\"Instrument\",Symbol,\" not found, using contract multiplier of 1\"))\n            ConMult<-1\n        } else {\n            ConMult<-tmp_instr$multiplier\n        }\n    }\n\n    # Calculate the value and average cost of the transaction\n    TxnValue = .calcTxnValue(TxnQty, TxnPrice, 0, ConMult) # Gross of Fees\n    TxnAvgCost = .calcTxnAvgCost(TxnValue, TxnQty, ConMult)\n\n    # Calculate the change in position\n    PosQty = PrevPosQty + TxnQty\n\n\n    # Calculate the resulting position's average cost\n    PrevPosAvgCost = .getPosAvgCost(pname, Symbol, TxnDate)\n    PosAvgCost = .calcPosAvgCost(PrevPosQty, PrevPosAvgCost, TxnValue, PosQty, ConMult)\n\n\t\n    # Calculate any realized profit or loss (net of fees) from the transaction\n    GrossTxnRealizedPL = TxnQty * ConMult * (PrevPosAvgCost - TxnAvgCost)\n\n  \t# if the previous position is zero, RealizedPL = 0\n  \t# if previous position is positive and position is larger, RealizedPL =0\n  \t# if previous position is negative and position is smaller, RealizedPL =0\n  \tif(abs(PrevPosQty) < abs(PosQty) | (PrevPosQty == 0))\n  \t\tGrossTxnRealizedPL = 0\n\t\n\t  NetTxnRealizedPL = GrossTxnRealizedPL + txnfees\n\n    # Store the transaction and calculations\n    NewTxn = xts(t(c(TxnQty, TxnPrice, TxnValue, TxnAvgCost, PosQty, PosAvgCost, GrossTxnRealizedPL, txnfees, NetTxnRealizedPL, ConMult)), order.by=TxnDate)\n    #colnames(NewTxns) = c('Txn.Qty', 'Txn.Price', 'Txn.Value', 'Txn.Avg.Cost', 'Pos.Qty', 'Pos.Avg.Cost', 'Gross.Txn.Realized.PL', 'Txn.Fees', 'Net.Txn.Realized.PL', 'Con.Mult')\n    Portfolio$symbols[[Symbol]]$txn<-rbind(Portfolio$symbols[[Symbol]]$txn, NewTxn)\n\n    # Warn if the transaction timestamp is not after initDate\n    if(.index(NewTxn) <= .index(Portfolio$symbols[[Symbol]]$txn[1L,1L]))\n      warning(\"Transaction timestamp (\", index(NewTxn[1L,]), \") \",\n              \"is not after initDate (\", index(Portfolio$symbols[[Symbol]]$txn[1L,1L]), \").\")\n\n    if(verbose)\n      # print(paste(TxnDate, Symbol, TxnQty, \"@\",TxnPrice, sep=\" \"))\n      print(paste(format(TxnDate, \"%Y-%m-%d %H:%M:%S\"), Symbol, TxnQty, \"@\",TxnPrice, sep=\" \"))\n      #print(Portfolio$symbols[[Symbol]]$txn)\n}\n\n#' Example TxnFee cost function\n#' @param TxnQty total units (such as shares or contracts) transacted.  Positive values indicate a 'buy'; negative values indicate a 'sell'\n#' This is an example intended to demonstrate how a cost function could be used in place of a flat numeric fee.\n#' @param \\dots any other passthrough parameters\n#' @export\npennyPerShare <- function(TxnQty, ...) {\n    return(abs(TxnQty) * -0.01)\n}\n\n#' @rdname addTxn\n#' @export\naddTxns<- function(Portfolio, Symbol, TxnData , verbose=FALSE, ..., ConMult=NULL, allowRebates=FALSE, eps=1e-06)\n{\n    pname <- Portfolio\n    #If there is no table for the symbol then create a new one\n    if(is.null(.getPortfolio(pname)$symbols[[Symbol]]))\n        addPortfInstr(Portfolio=pname, symbols=Symbol)\n    Portfolio <- .getPortfolio(pname)\n\n    if(is.null(ConMult) | !hasArg(ConMult)){\n        tmp_instr<-try(getInstrument(Symbol), silent=TRUE)\n        if(inherits(tmp_instr,\"try-error\") | !is.instrument(tmp_instr)){\n            warning(paste(\"Instrument\",Symbol,\" not found, using contract multiplier of 1\"))\n            ConMult<-1\n        } else {\n            ConMult<-tmp_instr$multiplier\n        }  \n    }\n\n    # initialize new transaction object\n    NewTxns <- xts(matrix(NA_real_, nrow(TxnData), 10L), index(TxnData))\n    colnames(NewTxns) <- c('Txn.Qty', 'Txn.Price', 'Txn.Value', 'Txn.Avg.Cost', 'Pos.Qty', 'Pos.Avg.Cost', 'Gross.Txn.Realized.PL', 'Txn.Fees', 'Net.Txn.Realized.PL', 'Con.Mult')\n\n    # Warn if the transaction timestamp is not after initDate\n    if(.index(NewTxns[1L,1L]) <= .index(Portfolio$symbols[[Symbol]]$txn[1L,1L]))\n      warning(\"First transaction timestamp (\", index(NewTxns[1L,1L]), \") \",\n              \"is not after initDate (\", index(Portfolio$symbols[[Symbol]]$txn[1L,1L]), \").\")\n\n    if(!(\"TxnQty\" %in% colnames(TxnData))) {\n\twarning(paste(\"No TxnQty column found, what did you call it?\"))\n    } else {\n      NewTxns$Txn.Qty <- as.numeric(TxnData$TxnQty)\n\t}\n    if(!(\"TxnPrice\" %in% colnames(TxnData))) {\n\twarning(paste(\"No TxnPrice column found, what did you call it?\"))\n    } else {\n      NewTxns$Txn.Price <- as.numeric(TxnData$TxnPrice)\n\t}\n    if(\"TxnFees\" %in% colnames(TxnData)) {\n      NewTxns$Txn.Fees <- as.numeric(TxnData$TxnFees)\n    } else {\n      NewTxns$Txn.Fees <- 0\n    }\n  \n    if(any(NewTxns$Txn.Fees > 0) && !isTRUE(allowRebates)){\n      stop('Positive Transaction Fees should only be used in the case of broker/exchange rebates. See Documentation.')\n    }\n  \n    # split transactions that would cross through zero\n    Pos <- drop(cumsum(NewTxns$Txn.Qty))\n    Pos <- merge(Qty=Pos, PrevQty=lag(Pos))\n    PosCrossZero <- Pos$PrevQty!= 0 & sign(Pos$PrevQty+NewTxns$Txn.Qty) != sign(Pos$PrevQty) & Pos$PrevQty!= -NewTxns$Txn.Qty\n    PosCrossZero[1] <- FALSE\n    if(any(PosCrossZero)) {\n        # subset position object\n        Pos <- Pos[PosCrossZero,]\n        # subset transactions we need to split, and initialize objects we can alter\n        flatTxns <- initTxns <- NewTxns[PosCrossZero,]\n        # set quantity for flat and initiating transactions\n        flatTxns$Txn.Qty <- -Pos$PrevQty\n        initTxns$Txn.Qty <- initTxns$Txn.Qty + Pos$PrevQty\n        # calculate fees pro-rata by quantity\n        txnFeeQty <- NewTxns$Txn.Fees/abs(NewTxns$Txn.Qty)\n        flatTxns$Txn.Fees <- txnFeeQty * abs(flatTxns$Txn.Qty)\n        initTxns$Txn.Fees <- txnFeeQty * abs(initTxns$Txn.Qty)\n        # transactions need unique timestamps, so increment initiating transaction index\n        .index(initTxns) <- .index(initTxns) + 2*eps\n        # remove split transactions from NewTxns, add flat and initiating transactions\n        NewTxns <- rbind(NewTxns[!PosCrossZero,], flatTxns, initTxns)\n        rm(flatTxns, initTxns, txnFeeQty)  # clean up\n    }\n    rm(Pos, PosCrossZero)  # clean up\n    # calculate transaction values\n    NewTxns$Txn.Value <- .calcTxnValue(NewTxns$Txn.Qty, NewTxns$Txn.Price, 0, ConMult)  # Gross of fees\n    NewTxns$Txn.Avg.Cost <- .calcTxnAvgCost(NewTxns$Txn.Value, NewTxns$Txn.Qty, ConMult)\n    # intermediate objects to aid in vectorization; only first element is non-zero\n    initPosQty <- initPosAvgCost <- numeric(nrow(NewTxns))\n    initPosQty[1] <- getPosQty(pname, Symbol, start(NewTxns))\n    initPosAvgCost[1] <- .getPosAvgCost(pname, Symbol, start(NewTxns))\n    # cumulative sum of transaction qty + initial position qty\n    NewTxns$Pos.Qty <- cumsum(initPosQty + NewTxns$Txn.Qty)\n    # only pass non-zero initial position qty and average cost\n    NewTxns$Pos.Avg.Cost <- .calcPosAvgCost_C(initPosQty[1], initPosAvgCost[1], NewTxns$Txn.Value, NewTxns$Pos.Qty, ConMult)\n    # need lagged position average cost and quantity\n    lagPosAvgCost <- c(initPosAvgCost[1], NewTxns$Pos.Avg.Cost[-nrow(NewTxns)])\n    lagPosQty <- c(initPosQty[1], NewTxns$Pos.Qty[-nrow(NewTxns)])\n    NewTxns$Gross.Txn.Realized.PL <- NewTxns$Txn.Qty * ConMult * (lagPosAvgCost - NewTxns$Txn.Avg.Cost)\n    NewTxns$Gross.Txn.Realized.PL[abs(lagPosQty) < abs(NewTxns$Pos.Qty) | lagPosQty == 0] <- 0\n    NewTxns$Net.Txn.Realized.PL <- NewTxns$Gross.Txn.Realized.PL + NewTxns$Txn.Fees\n    NewTxns$Con.Mult <- ConMult\n\n    # update portfolio with new transactions\n    Portfolio$symbols[[Symbol]]$txn <- rbind(Portfolio$symbols[[Symbol]]$txn, NewTxns) \n\n    if(verbose) print(NewTxns)\n}\n\n#' Add cash dividend transactions to a portfolio.\n#' \n#' Adding a cash dividend does not affect position quantity, like a split would.\n#' \n#' @param Portfolio  A portfolio name that points to a portfolio object structured with \\code{\\link{initPortf}}.\n#' @param Symbol An instrument identifier for a symbol included in the portfolio, e.g., IBM.\n#' @param TxnDate  Transaction date as ISO 8601, e.g., '2008-09-01' or '2010-01-05 09:54:23.12345'.\n#' @param DivPerShare The amount of the cash dividend paid per share or per unit quantity.\n#' @param \\dots Any other passthrough parameters.\n#' @param TxnFees Fees associated with the transaction, e.g. commissions. See Details.\n#' @param verbose If TRUE (default) the function prints the elements of the transaction in a line to the screen, e.g., \"2007-01-08 IBM 50 @@ 77.6\". Suppress using FALSE.\n#' @param ConMult Contract or instrument multiplier for the Symbol if it is not defined in an instrument specification.\n#' @export\n#' @note\n#' # TODO add TxnTypes to $txn table\n#' \n#' # TODO add AsOfDate \n#' \naddDiv <- function(Portfolio, Symbol, TxnDate, DivPerShare, ..., TxnFees=0, ConMult=NULL, verbose=TRUE)\n{ # @author Peter Carl\n    pname <- Portfolio\n    #If there is no table for the symbol then create a new one\n    if(is.null(.getPortfolio(pname)$symbols[[Symbol]]))\n        addPortfInstr(Portfolio=pname, symbols=Symbol)\n    Portfolio <- .getPortfolio(pname)\n\n    if(is.null(ConMult) | !hasArg(ConMult)){\n        tmp_instr<-try(getInstrument(Symbol), silent=TRUE)\n        if(inherits(tmp_instr,\"try-error\") | !is.instrument(tmp_instr)){\n            warning(paste(\"Instrument\",Symbol,\" not found, using contract multiplier of 1\"))\n            ConMult<-1\n        } else {\n            ConMult<-tmp_instr$multiplier\n        }\n    }\n\n    # FUNCTION\n    # \n    TxnQty = 0\n    TxnPrice = 0\n#     TxnType = \"Dividend\"\n# TODO add TxnTypes to $txn table\n\n    # Get the current position quantity\n    PrevPosQty = getPosQty(pname, Symbol, TxnDate)\n    PosQty = PrevPosQty # no change to position, but carry it forward\n    # Calculate the value and average cost of the transaction\n    # The -1 multiplier allows a positive DivPerShare value to create a\n    # positive realized gain\n    TxnValue = -1 * PrevPosQty * DivPerShare * ConMult # Calc total dividend paid\n    TxnAvgCost = DivPerShare\n\n    # No change to the the resulting position's average cost\n    PrevPosAvgCost = .getPosAvgCost(pname, Symbol, TxnDate)\n    PosAvgCost = PrevPosAvgCost # but carry it forward in $txn\n\n    # Calculate any realized profit or loss (net of fees) from the transaction\n    GrossTxnRealizedPL = PrevPosQty * DivPerShare * ConMult\n    NetTxnRealizedPL = GrossTxnRealizedPL + TxnFees\n\n    # Store the transaction and calculations\n    NewTxn = xts(t(c(TxnQty, TxnPrice, TxnValue, TxnAvgCost, PosQty, PosAvgCost, GrossTxnRealizedPL, TxnFees, NetTxnRealizedPL, ConMult)), order.by=as.POSIXct(TxnDate))\n    #colnames(NewTxns) = c('Txn.Qty', 'Txn.Price', 'Txn.Value', 'Txn.Avg.Cost', 'Pos.Qty', 'Pos.Avg.Cost', 'Gross.Txn.Realized.PL', 'Txn.Fees', 'Net.Txn.Realized.PL', 'Con.Mult')\n    Portfolio$symbols[[Symbol]]$txn<-rbind(Portfolio$symbols[[Symbol]]$txn, NewTxn)\n\n    if(verbose)\n        print(paste(TxnDate, Symbol, \"Dividend\", DivPerShare, \"on\", PrevPosQty, \"shares:\", -TxnValue, sep=\" \"))\n        #print(Portfolio$symbols[[Symbol]]$txn)\n}\n###############################################################################\n# Blotter: Tools for transaction-oriented trading systems development\n# for R (see http://r-project.org/)\n# Copyright (c) 2008-2015 Peter Carl and Brian G. Peterson\n#\n# This library is distributed under the terms of the GNU Public License (GPL)\n# for full details see the file COPYING\n#\n# $Id: addTxn.R 1740 2016-03-30 19:40:41Z bodanker $\n#\n###############################################################################\n",
    "created" : 1459626957618.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3003920111",
    "id" : "DDB53310",
    "lastKnownWriteTime" : 1459442402,
    "path" : "C:/Users/jasen/Personal/blotter/pkg/blotter/R/addTxn.R",
    "project_path" : "addTxn.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}